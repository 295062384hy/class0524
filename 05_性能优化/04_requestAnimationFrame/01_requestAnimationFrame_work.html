<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			*{
				margin: 0;
				padding: 0;
			}
			#test{
				width: 200px;
				height: 200px;
				background: pink;
				position: absolute;
				left: 0;
				right: 0;
				top: 0;
				bottom: 0;
				margin: auto;
			}
			
		</style>
	</head>
	<body>
		<div id="test"></div>
	</body>
	<script type="text/javascript">
		
		/*
		* window.requestAnimationFrame()
		* 	window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画
		* 	该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。
		* 
		* 
		* 	回调函数会被传入一个参数，DOMHighResTimeStamp，指示requestAnimationFrame() 开始触发回调函数的当前时间
		* 
		* 	返回值
		* 		一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。
		* 		你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数。
		* 
		* 
		* window.cancelAnimationFrame(requestID)
		* 		取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求.
		* 		requestID是先前调用window.requestAnimationFrame()方法时返回的ID.
		*/

		/*window.onload = function () {

    }*/

    window.addEventListener('DOMContentLoaded', function () {
			//获取dom元素
			const testNode = document.getElementById('test');
			let i = 0;

			/*//设置定时器
			const timer = setInterval(function () {
			  i++;
        testNode.style.left = i * 10 + 'px';

        if (i * 10 >= 500) {
					clearInterval(timer);
				}

      }, 1000/60)*/

			function step(time) {
				console.log(time);
				i++;
				testNode.style.left = i * 10 + 'px';
				//当位置小于500时，再次调用window.requestAnimationFrame来重新产生位移
				//如果在当前重排重绘过程中，有其他元素产生重排重绘，此时就会合并成一次，就只会产生一次重排重绘
				//减少页面重排重绘的次数
				if (i * 10 < 500) {
					window.requestAnimationFrame(step)
				}
			}

			window.requestAnimationFrame(step)

    })
				
		
	</script>
</html>
